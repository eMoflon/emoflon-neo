// Setup 2
import "platform:/resource/ClassToRelational/src/metamodels/Class.msl"
// Setup 2
import "platform:/resource/ClassToRelational/src/metamodels/Relational.msl"
// Setup 2
import "platform:/plugin/org.emoflon.neo.neocore/model/AttributeConstraintsLibrary.msl"
// Setup 2
import "platform:/resource/ClassToRelational/src/AttributeConstraints.msl"

// Setup 2
tripleGrammar ClassToRelational {
	// Setup 1
	source {
		// Setup 1
		class_
	}
	
	// Setup 1
	target {
		// Setup 1
		relational_
	}
	
	// Setup 1
	correspondence {
		// Tracing 3
		Class <- ClassToTable -> Table
		// Tracing 3
		DataType <- DateTypeToType -> Type
		// Tracing 3
		Attribute <- AttributeToColumn -> Column
		// Tracing 3
		Attribute <- AttributeToTable -> Table
		// Tracing 3
		Class <- ClassToType -> Type
	}
	
	// Setup 1
	rules {
		// Setup 1
		ClassToTable
		// Setup 1
		DataTypeToType

		// Setup 1
		PrimitiveAttributeToColumn
		// Setup 1		
		ClassAttributeToColumn
		// Setup 1		
		ClassAttributeToColumnNonInjective

		// Setup 1
		PrimitiveAttributeToTable
		// Setup 1		
		ClassAttributeToTable
		// Setup 1		
		ClassAttributeToTableNonInjective
	}
}

// Setup 3
tripleRule ClassToTable : ClassToRelational {
	// Setup 1
	source {
		// Transformation 3
		++ class : Class {
			// Transformation 2
			.name := <className>
		}
		
		// Model Traversal 2
		integerType : DataType {
			// Model Traversal 2
			.name : "Integer"
		}
	}
	
	// Setup 1
	target {
		// Transformation 3
		++ table : Table {
			// Model Traversal 2
			.name := <className>
			// Transformation 3
			++-col->objectId
			// Transformation 3
			++-key->objectId
		}
		// Transformation 3
		++ objectId : Column {
			// Model Traversal 2
			.name := "objectId"
			// Transformation 3
			++-owner->table
			// Transformation 3
			++-type->integer
			// Transformation 3
			++-keyOf->table
		}
		
		// Model Traversal 2
		integer : Type {
			// Model Traversal 2
			.name : "Integer"
		}
	}
	
	// Setup 1
	correspondence {
		// Tracing 4
		++ class <-:ClassToTable-> table
		// Tracing 3
		integerType <-:DateTypeToType-> integer
	}
} 

tripleRule DataTypeToType : ClassToRelational {
	source {
		++ dataType : DataType {
			.name := <typeName>
		}
	}
	
	target {
		++ type : Type {
			.name := <typeName>
		}
	}
	
	correspondence { 
		++ dataType <-:DateTypeToType-> type
	}
}

tripleRule PrimitiveAttributeToColumn : ClassToRelational {
	source {
		class : Class {
			++-attr->attribute
		}
		
		++ attribute : Attribute {
			.name := <attrName>
			.multiValued := false
			++-owner->class
			++-type->attrType
		}
		
		attrType : DataType
	}
	
	target { 
		table : Table {
			++-col-> column
		}
		
		++ column : Column {
			.name := <attrName>
			++-type->colType
			++-owner->table
		}
		
		colType : Type
	}
	
	correspondence {
		class <- :ClassToTable->table
		attrType <-:DateTypeToType->colType
		++attribute <-:AttributeToColumn->column
	}
}

// Setup 3
tripleRule ClassAttributeToColumn : ClassToRelational {
	// Setup 1
	source {
		// Model Traversal 2
		class : Class {
			// Transformation 3
			++-attr->attribute
		}
		
		// Transformation 3
		++ attribute : Attribute {
			// Transformation 2
			.name := <attrName>
			// Transformation 2
			.multiValued := false
			// Transformation 3
			++-owner->class
			// Transformation 3
			++-type->attrType
		}
		
		// Model Traversal 2
		attrType : Class
	}
	
	// Setup 1
	target { 
		// Model Traversal 2
		table : Table {
			// Transformation 3
			++-col-> column
		}
		
		// Transformation 3
		++ column : Column {
			// Transformation 2
			.name := <colName>
			// Transformation 3
			++-type->integer
			// Transformation 3
			++-owner->table
		}
		
		// Model Traversal 2
		integer : Type {
			// Model Traversal 2
			.name : "Integer"
		}
	}
	
	// Setup 1
	correspondence {
		// Tracing 3
		class <- :ClassToTable->table
		// Tracing 4
		++attribute <-:AttributeToColumn->column
	}
	
	// Setup 1
	attributeConstraints {
		// Tracing 1
		addSuffix(
			// Tracing 2
			word=<attrName>,
			// Tracing 2
			suffix="Id",
			// Tracing 2
			result=<colName>
		)
	}
}

tripleRule ClassAttributeToColumnNonInjective : ClassToRelational {
	source {
		class : Class {
			++-attr->attribute
		}
		
		++ attribute : Attribute {
			.name := <attrName>
			.multiValued := false
			++-owner->class
			++-type->class
		}		
	}
	
	target { 
		table : Table {
			++-col-> column
		}
		
		++ column : Column {
			.name := <colName>
			++-type->integer
			++-owner->table
		}
		
		integer : Type {
			.name : "Integer"
		}
	}
	
	correspondence {
		class <- :ClassToTable->table
		++attribute <-:AttributeToColumn->column
	}
	
	attributeConstraints {
		addSuffix(
			word=<attrName>,
			suffix="Id",
			result=<colName>
		)
	}
}


tripleRule PrimitiveAttributeToTable : ClassToRelational {
	source {
		class : Class {
			.name : <className>
			++-attr->attribute
		}
		
		++ attribute : Attribute {
			.name := <attrName>
			.multiValued := true
			++-owner->class
			++-type->attrType
		}
		
		attrType : DataType
	}
	
	target { 	
		++ table : Table {
			.name := <tableName>
			++-col->column
			++-col->id
		}
		
		++ id : Column {
			.name := <idName>
			++-type->integer
			++-owner->table
		}
		
		++ column : Column {
			.name := <attrName>
			++-owner->table
			++-type->colType
		}
		
		colType : Type
		
		integer : Type {
			.name : "Integer"
		}
	}
	
	correspondence {
		++attribute <-:AttributeToTable->table
		attrType <-:DateTypeToType->colType
		
	}
	
	attributeConstraints {
		concat(
			separator="_",
			left=<className>,
			right=<attrName>,
			combined=<tableName>
		)
		
		firstToLowerCase(
			word=<className>,
			lowerCase=<lower>
		)
		
		addSuffix(
			word=<lower>,
			suffix="Id",
			result=<idName>
		)
	}
}

tripleRule ClassAttributeToTable : ClassToRelational {
	source {
		class : Class {
			.name : <className>
			++-attr->attribute
		}
		
		++ attribute : Attribute {
			.name := <attrName>
			.multiValued := true
			++-owner->class
			++-type->attrType
		}
		
		attrType : Class
		
		integerType : DataType {
			.name : "Integer"
		}
	}
	
	target { 	
		++ table : Table {
			.name := <tableName>
			++-col->column
			++-col->id
		}
		
		++ id : Column {
			.name := <idName>
			++-type->integer
			++-owner->table
		}
		
		++ column : Column {
			.name := <attrIdName>
			++-owner->table
			++-type->integer
		}
		
		integer : Type {
			.name : "Integer"
		}
	}
	
	correspondence {
		++attribute <-:AttributeToTable->table
		integerType <-:DateTypeToType-> integer
	}
	
	attributeConstraints {
		concat(
			separator="_",
			left=<className>,
			right=<attrName>,
			combined=<tableName>
		)
		
		firstToLowerCase(
			word=<className>,
			lowerCase=<lower>
		)
		
		addSuffix(
			word=<lower>,
			suffix="Id",
			result=<idName>
		)
		
		addSuffix(
			word=<attrName>,
			suffix="Id",
			result=<attrIdName>
		)
	}
}

tripleRule ClassAttributeToTableNonInjective : ClassToRelational {
	source {
		class : Class {
			.name : <className>
			++-attr->attribute
		}
		
		++ attribute : Attribute {
			.name := <attrName>
			.multiValued := true
			++-owner->class
			++-type->class
		}
	}
	
	target { 	
		++ table : Table {
			.name := <tableName>
			++-col->column
			++-col->id
		}
		
		++ id : Column {
			.name := <idName>
			++-type->integer
			++-owner->table
		}
		
		++ column : Column {
			.name := <attrName>
			++-owner->table
			++-type->integer
		}
		
		integer : Type {
			.name : "Integer"
		}
	}
	
	correspondence {
		++attribute <-:AttributeToTable->table
	}
	
	attributeConstraints {
		concat(
			separator="_",
			left=<className>,
			right=<attrName>,
			combined=<tableName>
		)
		
		firstToLowerCase(
			word=<className>,
			lowerCase=<lower>
		)
		
		addSuffix(
			word=<lower>,
			suffix="Id",
			result=<idName>
		)
	}
}